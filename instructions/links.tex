% TO BE DONE 19th April
% ALSO GIVE LAB ASSIGNMENT ON 19th APRIL
% 1st deadline: 26th
% final: 3rd May

% How is it graded
% How did they split the work

%
%  untitled
%
%  Created by Nicholas Trevor Rutherford on 2013-03-19.
%  Copyright (c) 2013 __MyCompanyName__. All rights reserved.
%
\documentclass[a4paper]{article}

% Use utf-8 encoding for foreign characters
\usepackage[utf8]{inputenc}

% Setup for fullpage use
% \usepackage{fullpage}

% Uncomment some of the following if you use the features
%
% Running Headers and footers
%\usepackage{fancyhdr}

% Multipart figures
%\usepackage{subfigure}

% More symbols
% \usepackage{amsmath}
% \usepackage{amssymb}
%\usepackage{latexsym}
\newcommand{\union}{\cup}

% Surround parts of graphics with box
% \usepackage{boxedminipage}

% Package for including code in the document
\usepackage{listings}

\usepackage[ruled,vlined]{algorithm2e}

\usepackage{hyperref}


% This is now the recommended way for checking for PDFLaTeX:
\usepackage{ifpdf}

%\newif\ifpdf
%\ifx\pdfoutput\undefined
%\pdffalse % we are not running PDFLaTeX
%\else
%\pdfoutput=1 % we are running PDFLaTeX
%\pdftrue
%\fi

\ifpdf
\usepackage[pdftex]{graphicx}
\else
\usepackage{graphicx}
\fi
\title{LSINF2345 Lab: Implementing the basic abstractions}
\author{Nicholas Rutherford}

\date{April 2013}


\begin{document}
\lstset{language=erlang}

\ifpdf
\DeclareGraphicsExtensions{.pdf, .jpg, .tif}
\else
\DeclareGraphicsExtensions{.eps, .jpg}
\fi

\maketitle


\section{Introduction}

In this lab you will explore the software framework for the coursework
assignment. It provides the component stack, node (process) configuration,
and the fair-loss and stubborn link components. These components should be
used as a template for your own components. You will build the perfect-link,
a failure detector, and a reliable broadcast component.

\subsection{How to work} % (fold)
\label{sub:how_to_work}

Attempt the following exercises in the same pairs you will use for your graded
coursework. It is expected that you will use code from this lab in your
coursework.

% subsection how_to_work (end)

\subsection{Where to find help} % (fold)
\label{sub:where_to_find_help}

Erlang documentation can be found with Google, or at the reference
manual\footnote{\url{http://www.erlang.org/doc/apps/stdlib/index.html}}, and
its re-designed copy \url{http://erldocs.com}.
For algorithms refer to the course slides and textbook \cite{cachin2011}.
Also, ask the assistant.

As for the coursework, it's ok to talk to the other students about how to
solve the problems, but don't copy their code.

% subsection where_to_find_help (end)

\section{Framework overview} % (fold)
\label{sec:framework_overview}

This section briefly explains the role of key framework files.

\subsection{Components} % (fold)
\label{sub:components}

We provide the two basic point-to-point communication abstractions,
\emph{fll} and \emph{sl}. You should use \emph{sl} as a template for your
higher-layer components.

\subsubsection{fll.erl Fair-loss link} % (fold)
\label{ssub:fll_erl}

Fair-loss links provide best-effort point-to-point communication between
discrete processes (nodes). Recall that while this link is unreliable, it is
used by the higher level components, which provide stronger abstractions such
as reliable delivery.

Hopefully you will find that the component's implementation looks very
similar to the algorithm presented in the course book \cite{cachin2011}.

The details of inter-node communication have been abstracted away in the stack
module. You should assume best-effort (unreliable) communication, as described
for the \emph{fll} component. That is, a message may fail to arrive, and no ordering
guarantees or time bounds are provided, but some messages will arrive --
unreliable, but not useless\footnote{Erlang's primitives build on TCP and tend
to give stronger guarantees, so for testing purposes we have injected
additional problems by randomly dropping and delaying sent and received
transmissions.}.

If you'd like to use \lstinline!io:format! yourself to make your program more
chatty, refer to the
documentation\footnote{\url{http://erlang.org/doc/man/io.html\#format-1}} or
the side note at \url{http://learnyousomeerlang.com/syntax-in-functions} to
find out about the string substitution characters \lstinline!'~w~n'!.

% subsubsection fll_erl (end)

\subsubsection{sl.erl Stubborn link} % (fold)
\label{ssub:sl_erl_stubborn_link}

Stubborn links build on fair-loss links by guaranteeing that a sent message
will eventually arrive at its destination â€“ in fact it will arrive many times.

Here you can see how stack:trigger is used to create the stack events
prescribed by the book's algorithms. Here it's used to request that \emph{fll} sends
a message on its behalf. These are asynchronously broadcast to the other components,
which will act on them or ignore them according to (your implementation of)
their algorithm.

Note how a timer is used to periodically trigger the component's timeout event
and re-send the messages. Also see the sets documentation for methods that
might be useful in your own code. You might prefer lists, or some other
structure\footnote{\url{http://learnyousomeerlang.com/a-short-visit-to-common-data-structures}}.

In case you're not familiar with higher-order functions, \lstinline!sets:fold!
is used to execute the given function once for each set element. We don't use
the returned accumulator value as here we were only interested in fold as an
iterator. The lists library also provides map and some other functions.

As a final point, examine the tagging of sent messages and filtering of
received messages. This is important, as without the means to identify which
messages were sent by \emph{sl}, it would also deliver messages not sent by \emph{sl},
violating the no-creation property. Other solutions might involve
point-to-point messaging rather than broadcasting of events within the stack.
Here we retain the notion that all events are seen by all components, and
rely on them structuring and filtering their messages accordingly.

% subsubsection sl_erl_stubborn_link (end)

% subsection components (end)



\subsection{Internals} % (fold)
\label{sub:internals}

In order to understand the implementation of the provided abstraction you
may find the following useful:
\url{http://www.erlang.org/doc/man/gen_server.html}\\
\url{http://learnyousomeerlang.com/clients-and-servers}

\subsubsection{stack.erl} % (fold)
\label{sub:stack_erl}

The stack module is responsible for loading components, propagating events
within the stack, and ensuring the stack is the unit-of-failure: when one
component crashes the entire stack stops.

% subsection stack_erl (end)

\subsubsection{component.erl} % (fold)
\label{sub:component_erl}

The component module is an abstraction to hide some irrelevant implementation
details from you regarding their startup and the propagation and receipt of
stack events.

% subsection component_erl (end)

% subsection internals (end)



\section{Lab activity} % (fold)
\label{sec:lab_activity}

The following exercises will have you implement your first components with the
framework.

\subsection{Implement perfect links} % (fold)
\label{sub:implement_pl}

In a new file, \verb!src/pl.erl!, implement the ``Perfect Link'' abstraction
with Algorithm~\ref{algo:pl}. Use the \emph{sl} component as a template.

%TODO: insert the algorithm here

% \begin{verbatim}
% Algorithm 2.2: Eliminate Duplicates
% Implements: PerfectPointToPointLinks, instance pl.
% Uses: StubbornPointToPointLinks, instance sl.
%
% upon event < pl, Init > do
%   delivered := emptyset;
%
% upon event <pl, Send | q, m > do
%   trigger < sl, Send | q, m >;
%
% upon event <sl, Deliver | p, m > do
%   if m in delivered then
%     delivered := delivered union {m};
%     trigger < pl, Deliver | p, m>;
% \end{verbatim}

\begin{algorithm}[htbp]
  \SetKw{KwImplements}{Implements: }{}{}
  \SetKw{KwUses}{Uses: }{}{}
  \SetKw{KwTrigger}{trigger}
  \SetKwProg{KwEvent}{upon event}{ do}{}

  \SetAlgoNoLine % \SetAlgoLined
  \KwImplements{PerfectPointToPointLinks, instance pl}.\\
  \KwUses{StubbornPointToPointLinks, instance sl}.\\
  \BlankLine

  \KwEvent{$<$ pl, Init $>$}{
    $delivered := emptyset$\;
  }
  \BlankLine

  \KwEvent{$< pl, Send | q, m >$}{
    \KwTrigger{$< sl, Send | q, m >$}\;
  }
  \BlankLine

  \KwEvent{$< sl, Deliver | p, m >$}{
    \uIf{m in delivered}{
      $delivered := delivered \union \{m\}$\;
      \KwTrigger{$< pl, Deliver | p, m>$}\;
    }
  }
  \BlankLine
 \caption{Eliminate Duplicates, by Cachin et al.}
 \label{algo:pl}
\end{algorithm}

The algorithm is theoretically sound, but in practice we have some problems
to resolve.

\subsubsection{Duplicate messages} % (fold)
\label{ssub:duplicate_messages}

Sometimes we want to send the same message twice. Take, for example, the
perfect failure detector's \emph{heartbeat\_reply} message. The message
content is identical each time a heartbeat reply is sent, but the messages are
independent. Each time a heartbeat is sent by \emph{pl} it should be delivered
exactly once. If the same message content is sent twice it should be
delivered twice, otherwise the failure detector would suspect all nodes at
the second heartbeat. Messages should be distinguished by the act of sending
them, not by their content.

Modify the algorithm so that if two requests arrive for the same message
the message is sent exactly twice. That is, each received send request
produces a unique message even if the contents of the sent messages are equal.

% subsubsection duplicate_messages (end)


\subsubsection{Maintain no-creation with shared components} % (fold)
\label{ssub:no_creation_with_multiple_stack_algorithms}

Modify the algorithm so that \emph{pl} only delivers its own messages, maintaining
the no-creation property. It should ignore \emph{sl} deliver events for messages not
sent by \emph{pl} (where \emph{pl} may be itself, or the \emph{pl} component
on another node). You may find
\verb!make_ref()!\footnote{\url{http://erlang.org/doc/man/erlang.html\#make_ref-0}}
useful for generating pseudo-random ids.

% subsubsection no_creation_with_multiple_stack_algorithms (end)

% subsection implement_pl (end)


\subsection{Implement \emph{p}, the perfect failure detector} % (fold)
\label{sub:implement_p}

% subsection implement_p (end)


\subsection{Implement best-effort and lazy reliable broadcast} % (fold)
\label{sub:implement_best_effort_and_reliable_broadcast}

% subsection implement_best_effort_and_reliable_broadcast (end)

\subsection{Implement Eventually P, and revisit the broadcast algorithms} % (fold)
\label{sub:implement_eventually_p_and_revisit_the_broadcast_algorithms}

Consider how Lazy Reliable Broadcast will function using eventually-P.
Implement Eager Reliable Broadcast.

% subsection implement_eventually_p_and_revisit_the_broadcast_algorithms (end)

% section lab_activity (end)

% section framework_overview (end)




\begin{thebibliography}{9}

\bibitem{cachin2011}
  C. Cachin, R. Guerraoui, and L. Rodrigues,
  \emph{Introduction to Reliable and Secure Distributed Programming}.
  Springer-Verlag, Berlin
  2nd Edition,
  2011.

\end{thebibliography}



\end{document}






