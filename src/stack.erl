-module(stack).
-behaviour(gen_server).
-include_lib("stack_state.hrl").

-export([
init/1, code_change/3, handle_call/3, handle_cast/2, handle_info/2, terminate/2,
launch_and_register_component/1, components/0, get_subscribers/1, start/0,
stop/0, subscribe_to_events/2, event/3, start_link/0
]).

-ifdef(TEST). %ifdef to prevent test-code compilation into ebin
-include_lib("eunit/include/eunit.hrl").
-endif.


%% API  ===================================================

start_link() ->
  %% http://erldocs.com/R15B/stdlib/gen_server.html#start_link/4
  gen_server:start_link({local, ?MODULE}, ?MODULE, [], []).

% launch and bind the stack module
start() ->
  gen_server:start({local, ?MODULE}, ?MODULE, [], []).

stop() ->
  gen_server:call(?MODULE, terminate).


% register a component in the stack and launch its dependencies
launch_and_register_component(Name) ->
  gen_server:call(?MODULE, {register_component, Name}).

% returns the currently registered components
components() ->
  {components, Components} = gen_server:call(?MODULE, get_components),
  Components.


event(Module, indication, Event) ->
  relay_event({Module, indication, Event}, get_subscribers(Module));
event(Module, request, Event) ->
  relay_event({Module, request, Event}, get_subscribers(Module)).

subscribe_to_events(Component, Subscriber) ->
  gen_server:call(?MODULE, {subscribe_events, Component, Subscriber}).

get_subscribers(Component) ->
  {subscribers, Subscribers} = gen_server:call(?MODULE, {get_subscribers, Component}),
  Subscribers.


%% gen_server callbacks ===================================================

% entry-point for newly spawned stack process
init([]) ->
  {ok, #state{}}.

terminate(normal, State) ->
  io:format("~w terminating stack.~n", [?MODULE]),
  lists:map(fun(Component) -> apply(Component, stop, []) end, ?STACKSET:to_list(State#state.components)),
  io:format("~w terminated.~n", [?MODULE]),
  ok.

%% blocking sync messages
% add a component to the stack
handle_call({register_component, Name}, _From, State) ->
  NextComponents = launch_component_and_dependencies_if_missing(Name, State#state.components),
  NextParents = add_subscribers(Name, dependencies(Name), State#state.parents),
  {reply, {registered, Name}, State#state{parents=NextParents, components=NextComponents}};

% return active stack components
handle_call(get_components, _From, State) ->
  {reply, {components, State#state.components}, State};

% subscribe a pid (or registered atom), or list of several, to a component's events
handle_call({subscribe_events, Component, Subscriber}, _From, State) ->
  NextParents = add_subscribers(Component, lists:flatten([Subscriber]), State#state.parents),
  {reply, subscribed, State#state{parents=NextParents}};

% return atoms/pids being sent events generated by the specified component
handle_call({get_subscribers, Component}, _From, State) ->
  {reply, {subscribers, ?STACKDICT:fetch(Component, State#state.parents)}, State};

% shut down the stack
handle_call(terminate, _From, State) ->
  {stop, normal, ok, State}.



handle_info(Msg, State) ->
  io:format("Unexpected message: ~p~n",[Msg]),
  {noreply, State}.

code_change(_OldVsn, State, _Extra) ->
  %% No change planned. The function is there for the behaviour,
  %% but will not be used. Only a version on the next
  {ok, State}.

%% non-blocking async messages
% not used internally, halt if received
handle_cast(Request, State) ->
  {stop, {unexpected_message, Request}, State}.




%% internals  ===================================================

% launch component (and check dependencies) if not already running
% returns updated launched component list
launch_component_and_dependencies_if_missing(Component, LaunchedComponents) ->
  case is_component_running(Component) of
    false ->
      lists:foldl(
        fun
          (Dependency, Accum) ->
            ok = launch_and_bind_component_if_not_runnning(Dependency),
            ?STACKSET:add_element(Dependency, Accum)
        end,
        LaunchedComponents,
        [Component | dependencies(Component)]
      );

    true ->
      % already launched, do nothing
      LaunchedComponents
  end.

add_subscribers(Subscribers, Children, Subscriptions) ->
  %% ?debugFmt('subscribing ~w to ~w with prior ~w', [Children, Component, Parents]),
  NormalisedSubscribers = lists:flatten([Subscribers]),
  lists:foldl(
    fun(Child, Accum) ->
      ?STACKDICT:append_list(Child, NormalisedSubscribers, Accum)
    end, Subscriptions, Children
  ).

-ifdef(TEST). %ifdef to prevent test-code compilation into ebin

add_subscribers_test() ->
  Actual = ?STACKDICT:to_list(add_subscribers(p, [b, c], ?STACKDICT:new())),
  Expected = ?STACKDICT:to_list(?STACKDICT:store(c, [p], (?STACKDICT:store(b, [p], ?STACKDICT:new())))),
  ?assertEqual(Expected, Actual).

add_multiple_subscribers_test() ->
  Actual = ?STACKDICT:to_list(add_subscribers(q, [b, c], add_subscribers(p, [b, c], ?STACKDICT:new()))),
  Expected = ?STACKDICT:to_list(?STACKDICT:store(c, [p, q], (?STACKDICT:store(b, [p, q], ?STACKDICT:new())))),
  ?assertEqual(Expected, Actual).

-endif.



dependencies(Component) ->
  apply(Component, dependencies, []).


% call component's start&bind function
launch_and_bind_component_if_not_runnning(Name) ->
  case is_component_running(Name) of
    false ->
      apply(Name, start_link, []),
      ok;
    true ->
      ok
  end.


is_component_running(Component) ->
   undefined =/= whereis(Component).


relay_event(Event, Receivers) ->
  %% ?debugFmt('relaying ~w to ~w~n', [Event, Receivers]),
  lists:map(fun
    (Receiver) ->
      Receiver ! Event
  end, Receivers).


-ifdef(TEST). %ifdef to prevent test-code compilation into ebin

relay_event_test() ->
  Spy1 = nspy:mock(),
  Spy2 = nspy:mock(),
  relay_event(arbitrary_terms, [Spy1, Spy2]),
  nspy:assert_message_received(Spy1, arbitrary_terms),
  nspy:assert_message_received(Spy2, arbitrary_terms).

-endif.
